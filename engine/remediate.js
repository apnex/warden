const fs = require('fs');
const path = require('path');
const { resolve } = require('./path_resolver');

function showHeader(title) {
    console.log("\n====================================================");
    console.log("      üõ†Ô∏è  WARDEN FIXER: " + title);
    console.log("====================================================\n");
}

function loadJSON(filePath) {
    if (!fs.existsSync(filePath)) return null;
    try {
        return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    } catch (e) {
        return null;
    }
}

function saveJSON(filePath, data) {
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

function remediateRegistry() {
    showHeader("Registry Repair (Referential Integrity)");
    const protocolsFile = resolve.registry('protocols.json');
    const deliverablesFile = resolve.registry('deliverables.json');
    
    const protocols = loadJSON(protocolsFile);
    const deliverables = loadJSON(deliverablesFile);
    
    if (!protocols || !deliverables) {
        console.error("‚ùå Error: Registries missing.");
        return;
    }

    const requiredDlrs = new Set();
    Object.values(protocols.protocol_library).forEach(proto => {
        Object.values(proto.states).forEach(state => {
            if (state.requirements) {
                Object.values(state.requirements).forEach(req => {
                    if (req.type === 'regex_match_output') {
                        const match = req.pattern.match(/DLR_[A-Z0-9_]+/);
                        if (match) requiredDlrs.add(match[0]);
                    }
                });
            }
        });
    });

    const existingDlrs = new Set(deliverables.deliverables.map(d => d.id));
    const missing = [...requiredDlrs].filter(id => !existingDlrs.has(id));

    if (missing.length === 0) {
        console.log("‚úÖ PASS: Referential integrity intact.");
        return;
    }

    console.log("üîç Detected " + missing.length + " missing deliverables.");
    missing.forEach(id => {
        console.log("  [+] Creating stub for: " + id);
        deliverables.deliverables.push({
            id,
            name: id + " (Auto-Generated Stub)",
            description: "Automatically generated by Warden Fixer.",
            purpose: "To satisfy referential integrity.",
            scope: "Remediation",
            persistence: "CLI Log",
            schema: { type: "object", properties: { "note": { "type": "string" } }, required: ["note"] }
        });
    });

    saveJSON(deliverablesFile, deliverables);
    console.log("\n‚úÖ SUCCESS: Registry repaired.");
}

function remediateSchemas(targetPath) {
    showHeader("Schema Alignment (High-Fidelity Patching)");
    if (!targetPath || !fs.existsSync(targetPath)) {
        console.error("‚ùå Error: Target file missing.");
        return;
    }

    const target = loadJSON(targetPath);
    if (target && target.claims) {
        console.log("[Assessment] Aligning " + path.basename(targetPath) + " with High-Fidelity standards...");
        console.log("  [!] Feature note: Using 'oracle.js blueprint' is recommended.");
    }
    console.log("‚úÖ SUCCESS: Schema check complete.");
}

function remediateCleanup() {
    showHeader("Governance Debt Cleanup (Tiered Persistence)");
    
    const activeStateFile = resolve.state('active.json');
    const stack = loadJSON(activeStateFile) || [];
    
    if (stack.length === 0) {
        console.log("üßπ No active stack. Purging ephemeral execution state...");
        const stateDir = resolve.state();
        if (fs.existsSync(stateDir)) {
            const files = fs.readdirSync(stateDir);
            files.forEach(file => {
                const fullPath = resolve.state(file);
                if (file !== 'onboard.json' && file !== 'quiz_cert.json') {
                    fs.unlinkSync(fullPath);
                    console.log("  [PURGE] " + file);
                }
            });
        }
    } else {
        console.log("üõ°Ô∏è  Active stack detected. Pruning skipped.");
    }

    console.log("\n‚úÖ SUCCESS: Cleanup complete.");
}

function remediateSQA() {
    showHeader("Automatic SQA Mapping (Socratic Guidance)");
    
    const sessionLog = resolve.state('session.log');
    if (!fs.existsSync(sessionLog)) {
        console.error("‚ùå Error: Session log not found.");
        return;
    }

    const logs = fs.readFileSync(sessionLog, 'utf8').split('\n').filter(l => l.trim() !== '');
    const missionEntry = logs.reverse().find(l => l.includes('DLR_BRF_MISSION') && JSON.parse(l).output);
    
    if (!missionEntry) {
        console.error("‚ùå Error: No Mission Brief found in session logs.");
        return;
    }

    const content = JSON.parse(missionEntry).output.toLowerCase();
    
    const mapping = {
        "refactor,cleanup,structure,delete": "maintainability",
        "verify,test,demonstrate,prove": "testability",
        "protocol,gate,rule,standard": "compliance",
        "fast,slow,latency,optimize": "performance_efficiency",
        "breach,security,auth,secret": "security",
        "error,crash,stable,robust": "robustness"
    };

    const candidates = [];
    Object.entries(mapping).forEach(([keywords, attr]) => {
        if (keywords.split(',').some(k => content.includes(k))) {
            candidates.push(attr);
        }
    });

    if (candidates.length === 0) {
        console.log("üîç No specific SQA anchors detected in Mission Brief.");
        return;
    }

    console.log("üîç ANALYTICAL HINT: Based on your Mission Brief, these attributes are at risk of drift:");
    candidates.forEach(c => console.log("  - " + c));
    
    console.log("\nüìù INSTRUCTION: Analyze these candidates.");
    console.log("   For each one you select, you MUST provide a Strategic Rationale in your Strategic Proposal (DLR_PLN_GSD).");
    console.log("\n   Command Template:");
    console.log("   node validation/audit_standards.js --sqa \"" + candidates.join(', ') + "\"");
}

const [,, command, arg1] = process.argv;

switch (command) {
    case '--registry': remediateRegistry(); break;
    case '--schemas': remediateSchemas(arg1); break;
    case '--cleanup': remediateCleanup(); break;
    case '--sqa': remediateSQA(); break;
    default:
        console.log("Usage: node engine/remediate.js [--registry | --schemas <file> | --cleanup | --sqa]");
}
