const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { SOURCES, WARDEN, STATE, ROOT, resolve } = require('./path_resolver');

function showHeader(title) {
    console.log("\n====================================================");
    console.log(`      üõ†Ô∏è  WARDEN FIXER: ${title}`);
    console.log("====================================================\n");
}

function loadJSON(filePath) {
    if (!fs.existsSync(filePath)) return null;
    return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function saveJSON(filePath, data) {
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
}

// #1 Registry Repair
function remediateRegistry() {
    showHeader("Registry Repair (Referential Integrity)");
    const protocols = loadJSON(SOURCES.PROTOCOLS);
    const deliverables = loadJSON(SOURCES.DELIVERABLES);
    
    if (!protocols || !deliverables) {
        console.error("‚ùå Error: Registries missing.");
        return;
    }

    const requiredDlrs = new Set();
    Object.values(protocols.protocol_library).forEach(proto => {
        Object.values(proto.states).forEach(state => {
            if (state.requirements) {
                Object.values(state.requirements).forEach(req => {
                    if (req.type === 'regex_match_output') {
                        const match = req.pattern.match(/DLR_[A-Z0-9_]+/);
                        if (match) requiredDlrs.add(match[0]);
                    }
                });
            }
        });
    });

    const existingDlrs = new Set(deliverables.deliverables.map(d => d.id));
    const missing = [...requiredDlrs].filter(id => !existingDlrs.has(id));

    if (missing.length === 0) {
        console.log("‚úÖ PASS: Referential integrity intact.");
        return;
    }

    console.log(`üîç Detected ${missing.length} missing deliverables.`);
    missing.forEach(id => {
        console.log(`  [+] Creating stub for: ${id}`);
        deliverables.deliverables.push({
            id,
            name: `${id} (Auto-Generated Stub)`,
            description: "Automatically generated by Warden Fixer.",
            purpose: "To satisfy referential integrity.",
            scope: "Remediation",
            persistence: "CLI Log",
            schema: { type: "object", properties: { "note": { "type": "string" } }, required: ["note"] }
        });
    });

    saveJSON(SOURCES.DELIVERABLES, deliverables);
    console.log("\n‚úÖ SUCCESS: Registry repaired.");
}

// #2 Schema Alignment
function remediateSchemas(targetPath) {
    showHeader("Schema Alignment (High-Fidelity Patching)");
    if (!targetPath || !fs.existsSync(targetPath)) {
        console.error("‚ùå Error: Target file missing.");
        return;
    }

    const target = loadJSON(targetPath);
    const deliverables = loadJSON(SOURCES.DELIVERABLES);
    
    // Example: Alignment for engineer_report.json (claims vs interactions)
    if (target.claims) {
        console.log(`[Assessment] Aligning ${path.basename(targetPath)} with High-Fidelity standards...`);
        // Logic to ensure claims match interaction KINDs
        // (This would use blueprint logic to inject missing fields)
        console.log("  [!] Feature note: Using 'oracle.js blueprint' is recommended.");
    }
    console.log("‚úÖ SUCCESS: Schema check complete.");
}

// #3 Governance Debt Cleanup
function remediateCleanup() {
    showHeader("Governance Debt Cleanup (Tiered Persistence)");
    
    // 1. Centralized State Migration (Deprecated: Migration assumed complete)
    if (!fs.existsSync(STATE)) fs.mkdirSync(STATE, { recursive: true });

    // 2. Pruning Ephemeral State
    const stack = loadJSON(WARDEN.ACTIVE_STATE) || [];
    if (stack.length === 0) {
        console.log("üßπ No active stack. Purging ephemeral execution state...");
        const files = fs.readdirSync(STATE);
        files.forEach(file => {
            const fullPath = resolve.state(file);
            if (file !== 'onboard.json' && file !== 'quiz_cert.json') {
                fs.unlinkSync(fullPath);
                console.log(`  [PURGE] ${file}`);
            }
        });
    } else {
        console.log("üõ°Ô∏è  Active stack detected. Pruning skipped.");
    }

    console.log("\n‚úÖ SUCCESS: Cleanup complete.");
}

// #4 Automatic SQA Mapping
function remediateSQA() {
    showHeader("Automatic SQA Mapping (Socratic Guidance)");
    
    const logs = fs.readFileSync(WARDEN.SESSION_LOG, 'utf8').split('\n').filter(l => l.trim() !== '');
    // Find entries with DLR_BRF_MISSION and actual output
    const missionEntry = logs.reverse().find(l => l.includes('DLR_BRF_MISSION') && JSON.parse(l).output);
    
    if (!missionEntry) {
        console.error("‚ùå Error: No Mission Brief found in session logs.");
        return;
    }

    const content = JSON.parse(missionEntry).output.toLowerCase();
    
    const mapping = {
        "refactor,cleanup,structure,delete": "maintainability",
        "verify,test,demonstrate,prove": "testability",
        "protocol,gate,rule,standard": "compliance",
        "fast,slow,latency,optimize": "performance_efficiency",
        "breach,security,auth,secret": "security",
        "error,crash,stable,robust": "robustness"
    };

    const candidates = [];
    Object.entries(mapping).forEach(([keywords, attr]) => {
        if (keywords.split(',').some(k => content.includes(k))) {
            candidates.push(attr);
        }
    });

    if (candidates.length === 0) {
        console.log("üîç No specific SQA anchors detected in Mission Brief.");
        return;
    }

    console.log("üîç ANALYTICAL HINT: Based on your Mission Brief, these attributes are at risk of drift:");
    candidates.forEach(c => console.log(`  - ${c}`));
    
    console.log("\nüìù INSTRUCTION: Analyze these candidates.");
    console.log("   For each one you select, you MUST provide a Strategic Rationale in your Strategic Proposal (DLR_PLN_GSD).");
    console.log("\n   Command Template:");
    console.log(`   node validation/audit_standards.js --sqa "${candidates.join(', ')}"`);
}

const [,, command, arg1] = process.argv;

switch (command) {
    case '--registry': remediateRegistry(); break;
    case '--schemas': remediateSchemas(arg1); break;
    case '--cleanup': remediateCleanup(); break;
    case '--sqa': remediateSQA(); break;
    default:
        console.log("Usage: node engine/remediate.js [--registry | --schemas <file> | --cleanup | --sqa]");
}
